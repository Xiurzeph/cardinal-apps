<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cardinal Address Lookup</title>
    <!-- Favicon -->
    <link rel="icon" href="https://cardinalcomputersystems.com/cardinal-logo.png" type="image/png">
    </head>
    <body>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- GLOBAL ERROR HANDLER (Debugging "White Screen" issues) -->
    <script>
        window.onerror = function(message, source, lineno, colno, error) {
            const errorBox = document.createElement('div');
            errorBox.style.cssText = 'position:fixed;top:0;left:0;right:0;background:red;color:white;padding:20px;z-index:9999;font-family:monospace;';
            errorBox.innerHTML = `<strong>Global Error:</strong> ${message} <br>Line: ${lineno}`;
            document.body.appendChild(errorBox);
        };
    </script>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, GoogleAuthProvider, signInWithPopup, signInWithRedirect, getRedirectResult, signInAnonymously, onAuthStateChanged, signOut, signInWithCustomToken, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, updateDoc, onSnapshot, deleteDoc, doc, query, orderBy } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // =========================================================================
        // --- [STEP 1] FIREBASE CONFIGURATION ---
        // =========================================================================
        
        let firebaseConfig = {
            apiKey: "AIzaSyBM6AeJvD0TpXc-ypHKCuRI7suQLAjcFbI",
            // Using default domain to ensure login works immediately
            authDomain: "cardinal-address.firebaseapp.com",
            projectId: "cardinal-address",
            storageBucket: "cardinal-address.firebasestorage.app",
            messagingSenderId: "286969027972",
            appId: "1:286969027972:web:95b5e707cd5a02d6a0d1d1"
        };
        
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // --- AUTOMATIC ENV DETECTION ---
        try {
            if (typeof __firebase_config !== 'undefined') {
                const envConfig = JSON.parse(__firebase_config);
                // Merge to keep hardcoded keys if env is partial
                firebaseConfig = { ...firebaseConfig, ...envConfig };
            }
        } catch (e) {
            console.warn("Error parsing env config", e);
        }

        // =========================================================================
        // --- INITIALIZATION ---
        // =========================================================================

        let app, auth, db;

        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
        } catch (err) {
            document.body.innerHTML = `<div class="p-10 text-red-600 font-bold">Firebase Init Failed: ${err.message}</div>`;
            throw err;
        }

        // Global State
        window.currentUser = null;
        window.currentBatchData = null; 
        window.currentGroupStrikes = []; 
        window.currentBatchId = null;
        window.dbUnsubscribe = null;

        // --- HELPER UTILS ---
        function toggleClass(id, cls, add) {
            const el = document.getElementById(id);
            if (el) {
                add ? el.classList.add(cls) : el.classList.remove(cls);
            }
        }

        function setText(id, txt) {
            const el = document.getElementById(id);
            if (el) el.innerText = txt;
        }

        function updateProgress(current, total, text = "") {
            const percent = Math.round((current / total) * 100);
            const bar = document.getElementById('progressBar');
            const pct = document.getElementById('progressPercent');
            const txt = document.getElementById('progressText');
            if (bar) bar.style.width = `${percent}%`;
            if (pct) pct.innerText = `${percent}%`;
            if (txt) txt.innerText = text || `Processed ${current} of ${total}`;
        }

        // --- AUTH LOGIC ---
        async function initAuth() {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    try {
                        await getRedirectResult(auth);
                    } catch (e) {
                        console.error("Redirect Result Error:", e);
                    }
                }
            } catch (e) {
                console.error("Auth Init Error:", e);
            }
        }
        initAuth();

        onAuthStateChanged(auth, (user) => {
            if (user) {
                window.currentUser = user;
                toggleClass('login-screen', 'hidden', true);
                toggleClass('app-content', 'hidden', false);
                setText('user-display', user.email || "Guest User");
                
                if (user.isAnonymous) {
                    toggleClass('btn-tab-database', 'hidden', true);
                } else {
                    toggleClass('btn-tab-database', 'hidden', false);
                    initDatabaseListener(user.uid);
                }
            } else {
                window.currentUser = null;
                if (window.dbUnsubscribe) window.dbUnsubscribe();
                
                toggleClass('btn-save-db', 'hidden', true);
                toggleClass('btn-update-db', 'hidden', true);
                
                toggleClass('login-screen', 'hidden', false);
                toggleClass('app-content', 'hidden', true);
            }
        });

        // --- EXPOSE AUTH FUNCTIONS TO WINDOW ---
        window.googleLogin = async () => {
            const provider = new GoogleAuthProvider();
            try {
                await setPersistence(auth, browserLocalPersistence);
                await signInWithPopup(auth, provider);
            } catch (error) {
                console.error("Login Failed", error);
                if (error.code === 'auth/popup-blocked' || error.message.includes('missing initial state')) {
                    try {
                        await signInWithRedirect(auth, provider);
                    } catch (redirectError) {
                        alert("Login failed: " + redirectError.message);
                    }
                } else {
                    alert(`Login failed: ${error.message}`);
                }
            }
        };

        window.guestLogin = async () => {
            try {
                await signInAnonymously(auth);
            } catch (error) {
                if (error.code === 'auth/admin-restricted-operation') {
                    alert("Guest login is disabled in Firebase Console.");
                } else {
                    alert("Guest login failed: " + error.message);
                }
            }
        };

        window.logout = () => {
            signOut(auth);
        };

        // --- EXPOSE DATABASE FUNCTIONS TO WINDOW ---
        window.saveBatchToDb = async () => {
            if (!window.currentUser) return;
            if (!window.currentBatchData || window.currentBatchData.length === 0) {
                alert("No formatted data to save!");
                return;
            }
            
            const batchName = prompt("Enter a name for this batch:", `Batch ${new Date().toLocaleDateString()}`);
            if (!batchName) return;

            try {
                const userId = window.currentUser.uid;
                const colRef = collection(db, 'artifacts', appId, 'users', userId, 'data_batches');
                
                const docRef = await addDoc(colRef, {
                    name: batchName,
                    timestamp: Date.now(),
                    createdBy: window.currentUser.email || "Guest",
                    records: window.currentBatchData,
                    recordCount: window.currentBatchData.length,
                    groupStrikes: window.currentGroupStrikes || []
                });
                
                window.currentBatchId = docRef.id;
                toggleClass('btn-update-db', 'hidden', false);
                
                alert("Batch saved securely!");
                window.switchTab('database');
            } catch (e) {
                console.error("Save Error:", e);
                alert("Error saving: " + e.message);
            }
        };

        window.updateBatchInDb = async () => {
            if (!window.currentUser || !window.currentBatchId) return;
            
            try {
                const userId = window.currentUser.uid;
                const docRef = doc(db, 'artifacts', appId, 'users', userId, 'data_batches', window.currentBatchId);
                
                await updateDoc(docRef, {
                    records: window.currentBatchData,
                    recordCount: window.currentBatchData.length,
                    groupStrikes: window.currentGroupStrikes || [],
                    lastUpdated: Date.now()
                });
                
                alert("Batch updated successfully!");
                window.switchTab('database');
            } catch (e) {
                console.error("Update Error:", e);
                alert("Error updating batch: " + e.message);
            }
        };

        window.deleteBatch = async (docId) => {
            if (!confirm("Delete this batch?")) return;
            try {
                const userId = window.currentUser.uid;
                const docRef = doc(db, 'artifacts', appId, 'users', userId, 'data_batches', docId);
                await deleteDoc(docRef);
                if (window.currentBatchId === docId) {
                    window.currentBatchId = null;
                    toggleClass('btn-update-db', 'hidden', true);
                }
            } catch (e) {
                alert("Delete failed: " + e.message);
            }
        };

        window.refreshDatabase = () => {
            if (window.currentUser) {
                const tbody = document.getElementById('db-table-body');
                if (tbody) tbody.innerHTML = '<tr><td colspan="4" class="px-6 py-12 text-center text-gray-400">Refreshing data...</td></tr>';
                initDatabaseListener(window.currentUser.uid);
            }
        };

        function initDatabaseListener(userId) {
            if (window.dbUnsubscribe) window.dbUnsubscribe();

            const colRef = collection(db, 'artifacts', appId, 'users', userId, 'data_batches');
            
            window.dbUnsubscribe = onSnapshot(colRef, (snapshot) => {
                const batches = [];
                snapshot.forEach(doc => {
                    batches.push({ id: doc.id, ...doc.data() });
                });
                batches.sort((a, b) => b.timestamp - a.timestamp);
                renderDatabaseTable(batches);
            }, (error) => {
                console.error("DB Listener Error:", error);
            });
        }

        function renderDatabaseTable(batches) {
            const tbody = document.getElementById('db-table-body');
            if (!tbody) return;
            tbody.innerHTML = '';
            if (batches.length === 0) {
                tbody.innerHTML = `<tr><td colspan="4" class="px-6 py-8 text-center text-gray-400">No batches saved yet.</td></tr>`;
                return;
            }
            // Store globally for loading
            window.allBatches = batches;

            batches.forEach((batch, index) => {
                const date = new Date(batch.timestamp).toLocaleString();
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-slate-900">${batch.name || 'Untitled'}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-slate-500">${date}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-slate-500">${batch.recordCount || 0} Records</td>
                    <td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                        <button onclick="window.loadBatchFromMemory(${index})" class="text-red-700 hover:text-red-900 mr-4 font-semibold">Load</button>
                        <button onclick="window.deleteBatch('${batch.id}')" class="text-gray-400 hover:text-red-600">Delete</button>
                    </td>
                `;
                tbody.appendChild(tr);
            });
        }

        // --- EXPOSE UI FUNCTIONS TO WINDOW ---
        window.switchTab = (tabName) => {
            const tabs = ['formatter', 'database'];
            tabs.forEach(t => {
                const el = document.getElementById(`tab-${t}`);
                const btn = document.getElementById(`btn-tab-${t}`);
                if (t === tabName) {
                    if(el) el.classList.remove('hidden');
                    if(btn) {
                        btn.classList.remove('tab-inactive');
                        btn.classList.add('tab-active');
                    }
                } else {
                    if(el) el.classList.add('hidden');
                    if(btn) {
                        btn.classList.remove('tab-active');
                        btn.classList.add('tab-inactive');
                    }
                }
            });
            if (tabName === 'database') window.refreshDatabase();
        };

        window.loadBatchFromMemory = (index) => {
            const batch = window.allBatches[index];
            if (!batch) return;
            window.currentBatchData = batch.records;
            window.currentGroupStrikes = batch.groupStrikes || [];
            window.currentBatchId = batch.id;
            renderResults(batch.records, 0, `Loaded: ${batch.name}`);
            window.switchTab('formatter');
            if (!window.currentUser?.isAnonymous) {
                toggleClass('btn-save-db', 'hidden', false);
                toggleClass('btn-update-db', 'hidden', false);
            }
            alert(`Loaded batch "${batch.name}" with ${batch.records.length} records.`);
        };

        window.toggleGroupStrike = (groupIndex) => {
            const isStruck = !window.currentGroupStrikes[groupIndex];
            window.currentGroupStrikes[groupIndex] = isStruck;
            const groupDiv = document.getElementById(`group-div-${groupIndex}`);
            if (groupDiv) {
                isStruck ? groupDiv.classList.add('group-struck') : groupDiv.classList.remove('group-struck');
            }
            const btn = document.getElementById(`strike-btn-${groupIndex}`);
            if (btn) {
                if (isStruck) {
                    btn.className = 'p-1 rounded-md transition-colors no-print bg-red-100 text-red-700 shadow-sm';
                    btn.title = "Restore Group";
                } else {
                    btn.className = 'p-1 rounded-md transition-colors no-print text-gray-400 hover:text-gray-600 hover:bg-gray-100';
                    btn.title = "Strike Through Group";
                }
            }
        };

        // --- FORMATTER LOGIC (Exposed) ---
        const API_URL = "https://geodata.md.gov/imap/rest/services/PlanningCadastre/MD_PropertyData/MapServer/0/query";

        window.runLookupAndFormat = async function() {
            const rawInput = document.getElementById('csvInput').value.trim();
            if (!rawInput) return alert("Please enter addresses.");
            window.currentBatchId = null;
            toggleClass('btn-update-db', 'hidden', true);
            
            const requireOwnerOccupied = document.getElementById('chkOwnerOccupied').checked;
            const pgOnly = document.getElementById('chkPGOnly').checked;

            const lines = rawInput.split('\n').filter(l => l.trim().length > 0);
            const total = lines.length;
            
            updateProgress(0, total, "Starting...");
            toggleClass('progressContainer', 'hidden', false);

            const results = [];
            let processed = 0;
            let skipped = 0;
            let filtered = 0;

            for (const line of lines) {
                let searchAddress = cleanAddressForSearch(line);
                let foundMatch = false;
                const attempts = [searchAddress];
                const strictClean = cleanAddressStrict(line);
                if (strictClean !== searchAddress) attempts.push(strictClean);
                const relaxed = removeDirectionals(strictClean);
                if (relaxed !== strictClean) attempts.push(relaxed);
                if (strictClean.endsWith('S')) attempts.push(strictClean.slice(0, -1));

                for (let i = 0; i < attempts.length; i++) {
                    const term = attempts[i];
                    if (i > 0) updateProgress(processed, total, `Retrying: ${term}...`);

                    try {
                        const apiData = await fetchPropertyData(term, pgOnly);
                        if (apiData && apiData.features && apiData.features.length > 0) {
                            let targetAttr = null;
                            if (requireOwnerOccupied) {
                                for (const feature of apiData.features) {
                                    if (feature.attributes.OOI === 'H') {
                                        targetAttr = feature.attributes;
                                        break;
                                    }
                                }
                            } else {
                                const hMatch = apiData.features.find(f => f.attributes.OOI === 'H');
                                targetAttr = hMatch ? hMatch.attributes : apiData.features[0].attributes;
                            }
                            if (targetAttr) {
                                const formattedRecord = formatApiRecord(targetAttr);
                                results.push(formattedRecord);
                                foundMatch = true;
                                break;
                            } else {
                                filtered++;
                                foundMatch = true;
                                break; 
                            }
                        }
                    } catch (err) { console.error("API Error", err); }
                    if (i < attempts.length - 1) await new Promise(r => setTimeout(r, 200));
                }
                if (!foundMatch) skipped++;
                processed++;
                updateProgress(processed, total);
                await new Promise(r => setTimeout(r, 100)); 
            }

            window.currentBatchData = results;
            window.currentGroupStrikes = new Array(Math.ceil(results.length / 5)).fill(false);
            
            let statusMsg = `Processed ${total} addresses. Found ${results.length}. `;
            if (filtered > 0) statusMsg += `Filtered (Non-Owner): ${filtered}. `;
            if (skipped > 0) statusMsg += `Not Found: ${skipped}.`;
            
            renderResults(results, statusMsg);
            toggleClass('progressContainer', 'hidden', true);
            if (results.length > 0 && !window.currentUser?.isAnonymous) {
                toggleClass('btn-save-db', 'hidden', false);
            }
        };

        window.processCSVData = function() {
            const rawData = document.getElementById('csvInput').value.trim();
            if (!rawData) return alert("Please enter CSV data.");
            window.currentBatchId = null;
            toggleClass('btn-update-db', 'hidden', true);
            const lines = rawData.split('\n');
            let results = [];
            lines.forEach(line => {
                const cols = line.split(',').map(s => s.trim());
                if (cols.length < 5) return;
                results.push({
                    name: formatName(cols[0]),
                    address: toTitleCase(cols[1]),
                    city: toTitleCase(cols[2]),
                    state: cols[3].toUpperCase(),
                    zip: cols[4],
                    streetName: extractStreetName(cols[1])
                });
            });
            window.currentBatchData = results;
            window.currentGroupStrikes = new Array(Math.ceil(results.length / 5)).fill(false);
            renderResults(results, `Found ${results.length} records.`);
            if (results.length > 0 && !window.currentUser?.isAnonymous) toggleClass('btn-save-db', 'hidden', false);
        };

        // --- INTERNAL HELPERS ---
        function renderResults(data, statusText) {
            const canvas = document.getElementById('outputCanvas');
            const stats = document.getElementById('stats');
            if (canvas) canvas.innerHTML = '';
            if (stats) stats.innerHTML = statusText || "";
            if (data.length === 0) {
                if (canvas) canvas.innerHTML = '<div class="text-center text-red-500 mt-10">No valid properties found. Try unchecking "Require Owner-Occupied" or "PG County Only" if expected.</div>';
                return;
            }
            const chunkSize = 5;
            const numGroups = Math.ceil(data.length / chunkSize);
            if (!window.currentGroupStrikes || window.currentGroupStrikes.length !== numGroups) {
               const newStrikes = new Array(numGroups).fill(false);
               if(window.currentGroupStrikes) {
                   window.currentGroupStrikes.forEach((val, i) => { if(i < newStrikes.length) newStrikes[i] = val; });
               }
               window.currentGroupStrikes = newStrikes;
            }
            let groupCount = 0;
            for (let i = 0; i < data.length; i += chunkSize) {
                const groupIndex = groupCount;
                groupCount++;
                const group = data.slice(i, i + chunkSize);
                const groupDiv = document.createElement('div');
                groupDiv.className = 'mb-8 break-inside-avoid';
                groupDiv.id = `group-div-${groupIndex}`;
                const isStruck = window.currentGroupStrikes[groupIndex];
                if (isStruck) groupDiv.classList.add('group-struck');
                const headerContainer = document.createElement('div');
                headerContainer.className = 'flex justify-between items-end border-b border-gray-300 pb-1 mb-2';
                const header = document.createElement('h3');
                header.className = 'text-sm font-bold text-gray-500 uppercase tracking-wide';
                header.innerText = `Group ${groupCount}`;
                const actionBtn = document.createElement('button');
                actionBtn.id = `strike-btn-${groupIndex}`;
                actionBtn.onclick = () => window.toggleGroupStrike(groupIndex);
                actionBtn.title = isStruck ? "Restore Group" : "Strike Through Group";
                if (isStruck) {
                    actionBtn.className = 'p-1 rounded-md transition-colors no-print bg-red-100 text-red-700 shadow-sm';
                } else {
                    actionBtn.className = 'p-1 rounded-md transition-colors no-print text-gray-400 hover:text-gray-600 hover:bg-gray-100';
                }
                actionBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" d="M18.364 18.364A9 9 0 0 0 5.636 5.636m12.728 12.728A9 9 0 0 1 5.636 5.636m12.728 12.728L5.636 5.636" /></svg>`;
                headerContainer.appendChild(header);
                headerContainer.appendChild(actionBtn);
                groupDiv.appendChild(headerContainer);
                const table = document.createElement('table');
                table.className = 'address-table';
                group.forEach(item => {
                    const row = document.createElement('tr');
                    row.className = 'address-row';
                    const cell = document.createElement('td');
                    cell.innerHTML = `${item.name}, <strong>${item.address}</strong>, ${item.city} ${item.state} ${item.zip}`;
                    const borderColor = stringToColor(item.streetName);
                    cell.style.borderLeft = `6px solid ${borderColor}`;
                    row.appendChild(cell);
                    table.appendChild(row);
                });
                groupDiv.appendChild(table);
                if (canvas) canvas.appendChild(groupDiv);
            }
        }

        async function fetchPropertyData(cleanAddress, pgOnly = true) {
            const escaped = cleanAddress.replace(/'/g, "''");
            const fuzzyAddress = `%${cleanAddress.split(' ').join('%')}%`;
            
            const params = new URLSearchParams({
                where: `UPPER(ADDRESS) LIKE UPPER('${fuzzyAddress}')${pgOnly ? " AND JURSCODE = 'PRIN'" : ""}`,
                outFields: 'ACCTID,ADDRESS,CITY,ZIPCODE,OWNNAME1,OOI',
                returnGeometry: 'false',
                f: 'json',
                resultRecordCount: '10'
            });
            const targetUrl = `${API_URL}?${params.toString()}`;
            const proxies = [
                `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`,
                `https://api.allorigins.win/raw?url=${encodeURIComponent(targetUrl)}&timestamp=${Date.now()}`,
                `https://thingproxy.freeboard.io/fetch/${targetUrl}`
            ];
            let lastError = null;
            for (const proxyUrl of proxies) {
                try {
                    const response = await fetch(proxyUrl);
                    if (response.ok) {
                        const text = await response.text();
                        if (text.trim().startsWith('<')) continue;
                        try {
                            const data = JSON.parse(text);
                            if (data.features || data.error) return data;
                        } catch (e) {}
                    }
                } catch (e) { lastError = e; }
                await new Promise(r => setTimeout(r, 250));
            }
            throw new Error(`Unable to retrieve property data. All proxies failed.`);
        }

        function cleanAddressPreservingType(rawLine) {
            let text = rawLine.trim();
            if (text.includes('\t')) {
                const parts = text.split('\t');
                text = parts.length >= 2 ? `${parts[0].trim()} ${parts[1].trim()}` : parts[0].trim();
            }
            text = text.toUpperCase();
            const directions = {'EAST': 'E', 'WEST': 'W', 'NORTH': 'N', 'SOUTH': 'S', 'NORTHEAST': 'NE', 'NORTHWEST': 'NW', 'SOUTHEAST': 'SE', 'SOUTHWEST': 'SW'};
            for (const [full, abbr] of Object.entries(directions)) text = text.replace(new RegExp(`\\b${full}\\b`, 'g'), abbr);
            text = text.replace(/,?\s+MD.*$/, '').replace(/,?\s+CLINTON.*$/, '').replace(/\s+\d{5}(-\d{4})?$/, '');
            return text.trim();
        }

        function cleanAddressForSearch(rawLine) { return cleanAddressPreservingType(rawLine); }

        function cleanAddressStrict(text) {
            const streetTypes = ['ST', 'STREET', 'AVE', 'AVENUE', 'RD', 'ROAD', 'DR', 'DRIVE', 'CT', 'COURT', 'LN', 'LANE', 'PL', 'PLACE', 'WAY', 'BLVD', 'BOULEVARD', 'CIR', 'CIRCLE', 'TURN', 'TER', 'TERRACE', 'PKWY', 'PARKWAY', 'TRL', 'TRAIL', 'LOOP', 'PATH', 'WALK', 'RUN', 'GLEN', 'GROVE', 'RIDGE', 'HILL', 'VIEW'];
            const typeRegex = new RegExp(`\\s+(${streetTypes.join('|')})\\b.*$`, 'i');
            return text.replace(typeRegex, '').trim();
        }

        function removeDirectionals(cleanAddress) {
            return cleanAddress.replace(/\b(N|S|E|W|NE|NW|SE|SW)\b/g, '').replace(/\s+/g, ' ').trim();
        }

        function formatApiRecord(attr) {
            let ownerName = attr.OWNNAME1 || "Unknown";
            ownerName = ownerName.replace(/\s*ETAL\s*/g, '').replace(/\s*ET\s+AL\s*/g, '').trim();
            ownerName = ownerName.split('&')[0].trim();
            if (ownerName && !ownerName.includes(',')) {
                const parts = ownerName.split(/\s+/);
                if (parts.length >= 2) {
                    const last = parts[0];
                    const rest = parts.slice(1).join(' ');
                    ownerName = `${rest} ${last}`;
                }
            }
            const addressFull = toTitleCase(attr.ADDRESS || "");
            return {
                name: formatName(toTitleCase(ownerName)), 
                address: addressFull,
                city: toTitleCase(attr.CITY || ""),
                state: "MD",
                zip: attr.ZIPCODE || "",
                streetName: extractStreetName(addressFull)
            };
        }

        function extractStreetName(fullAddress) { return fullAddress.replace(/^[0-9]+\s*/, '').trim(); }
        function formatName(name) {
            if (!name) return "";
            let clean = name.split('&')[0].trim();
            clean = clean.replace(/ETAL/gi, '').replace(/ET\s+AL/gi, '').trim().replace(/\./g, '');
            if (clean.includes(',')) {
                const parts = clean.split(',');
                if (parts.length >= 2) {
                    const last = parts[0].trim();
                    const rest = parts[1].trim(); 
                    clean = `${rest} ${last}`;
                }
            }
            return toTitleCase(clean);
        }
        function stringToColor(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) hash = str.charCodeAt(i) + ((hash << 5) - hash);
            let color = '#';
            for (let i = 0; i < 3; i++) {
                let value = (hash >> (i * 8)) & 0xFF;
                if (value > 200) value = 200; 
                color += ('00' + value.toString(16)).substr(-2);
            }
            return color;
        }
    </script>
</body>
</html>
